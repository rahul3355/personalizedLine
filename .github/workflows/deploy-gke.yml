name: Build and Deploy to GKE

on:
  push:
    branches:
      - main
      - claude/*
  pull_request:
    branches:
      - main

env:
  GKE_CLUSTER: personalizedline
  GKE_REGION: us-central1
  DEPLOYMENT_NAME: personalizedline

jobs:
  build-and-push:
    name: Build and Push to GCR
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        export_default_credentials: true

    - name: Configure Docker for GCR
      run: |
        gcloud auth configure-docker

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push Docker image
      env:
        IMAGE: gcr.io/${{ secrets.GCP_PROJECT_ID }}/personalizedline
        TAG: ${{ github.sha }}
      run: |
        docker build -f backend/app/Dockerfile -t ${IMAGE}:${TAG} -t ${IMAGE}:latest .
        docker push ${IMAGE}:${TAG}
        docker push ${IMAGE}:latest

    - name: Upload image info
      uses: actions/upload-artifact@v4
      with:
        name: image-info
        path: |
          echo "gcr.io/${{ secrets.GCP_PROJECT_ID }}/personalizedline:${{ github.sha }}" > image.txt

  deploy:
    name: Deploy to GKE
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        export_default_credentials: true

    - name: Install gke-gcloud-auth-plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin

    - name: Get GKE credentials
      run: |
        gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
          --region ${{ env.GKE_REGION }} \
          --project ${{ secrets.GCP_PROJECT_ID }}

    - name: Verify kubectl connection
      run: |
        kubectl cluster-info
        kubectl get nodes

    - name: Deploy to Kubernetes
      env:
        DOCKER_IMAGE: gcr.io/${{ secrets.GCP_PROJECT_ID }}/personalizedline
        VERSION: ${{ github.sha }}
      run: |
        # Create namespace if it doesn't exist
        kubectl create namespace personalizedline --dry-run=client -o yaml | kubectl apply -f -

        # Apply Redis
        kubectl apply -f k8s/redis.yaml -n personalizedline

        # Apply Web with new image
        envsubst < k8s/web.yaml | kubectl apply -f - -n personalizedline

        # Apply Workers with new image
        envsubst < k8s/worker.yaml | kubectl apply -f - -n personalizedline

        # Apply KEDA scaler
        kubectl apply -f k8s/keda-scaler.yaml -n personalizedline

    - name: Wait for rollout
      run: |
        kubectl rollout status deployment/web -n personalizedline --timeout=5m
        kubectl rollout status deployment/rq-worker -n personalizedline --timeout=5m

    - name: Verify deployment
      run: |
        echo "Pods:"
        kubectl get pods -n personalizedline

        echo ""
        echo "Services:"
        kubectl get svc -n personalizedline

        echo ""
        echo "ScaledObjects:"
        kubectl get scaledobject -n personalizedline

        echo ""
        echo "External IP:"
        kubectl get svc web -n personalizedline -o jsonpath='{.status.loadBalancer.ingress[0].ip}'

    - name: Run smoke tests (optional)
      run: |
        # Get external IP
        EXTERNAL_IP=$(kubectl get svc web -n personalizedline -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        if [ ! -z "$EXTERNAL_IP" ]; then
          echo "Testing API at http://${EXTERNAL_IP}"
          # Add your smoke tests here
          # curl -f http://${EXTERNAL_IP}/health || exit 1
        else
          echo "External IP not yet assigned, skipping smoke tests"
        fi

  notification:
    name: Send deployment notification
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Deployment result
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "✅ Deployment successful!"
        else
          echo "❌ Deployment failed!"
          exit 1
        fi
